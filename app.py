"""
Sri Vengamamba Food Court - POS System Backend
Flask API for handling billing, analytics, and inventory management
"""

from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS
from flask_jwt_extended import JWTManager, create_access_token, jwt_required, get_jwt_identity
from pymongo import MongoClient, errors
from bson.objectid import ObjectId
from datetime import datetime, timedelta
from dotenv import load_dotenv
import os
import logging
import bcrypt
import re

# Configure logging FIRST (before MongoDB)
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Load environment variables FIRST
load_dotenv()

# MongoDB connection (lazy & correct)
MONGO_URI = os.getenv("MONGO_URI")
if not MONGO_URI:
    raise RuntimeError("MONGO_URI not found in .env")

client = MongoClient(MONGO_URI)
db = client["svfc_pos"]
bills_col = db["bills"]
counter_col = db["counters"]
users_col = db["users"]
custom_items_col = db["custom_items"]

logger.info("‚úÖ MongoDB client initialized")
# ============ AUTHENTICATION HELPERS ============

def hash_password(password):
    """Hash a password using bcrypt"""
    salt = bcrypt.gensalt(rounds=12)
    return bcrypt.hashpw(password.encode('utf-8'), salt).decode('utf-8')

def verify_password(password, hashed):
    """Verify a password against its hash"""
    return bcrypt.checkpw(password.encode('utf-8'), hashed.encode('utf-8'))

# ============ INITIALIZE DEFAULT USERS ============

def initialize_default_users():
    """Create or update default user accounts"""
    try:
        default_users = [
            {
                "username": "admin",
                "email": "admin@svfc.com",
                "password": "admin@256",
                "role": "admin"
            },
            {
                "username": "casher1",
                "email": "casher1@svfc.com",
                "password": "casher1@123",
                "role": "cashier"
            },
            {
                "username": "casher2",
                "email": "casher2@svfc.com",
                "password": "casher2@123",
                "role": "cashier"
            }
        ]

        allowed_emails = [user["email"] for user in default_users]
        users_col.delete_many({"email": {"$nin": allowed_emails}})

        for user in default_users:
            users_col.update_one(
                {"email": user["email"]},
                {
                    "$set": {
                        "username": user["username"],
                        "password": hash_password(user["password"]),
                        "role": user["role"]
                    },
                    "$setOnInsert": {"createdAt": datetime.now()}
                },
                upsert=True
            )

        logger.info("‚úÖ Default accounts ensured:")
        logger.info("   üëî Admin: admin@svfc.com (password: admin@256)")
        logger.info("   üí∞ Casher 1: casher1@svfc.com (password: casher1@123)")
        logger.info("   üí∞ Casher 2: casher2@svfc.com (password: casher2@123)")
        
    except Exception as e:
        logger.error(f"Error initializing users: {str(e)}")

# Initialize users on startup
initialize_default_users()

# ============ DATA RETENTION & CLEANUP ============

def cleanup_old_bills():
    """Delete bills older than 6 months automatically"""
    try:
        # Calculate cutoff date (6 months ago)
        cutoff_date = datetime.now() - timedelta(days=180)
        
        # Find and delete bills older than 6 months
        result = bills_col.delete_many({
            "createdAt": {"$lt": cutoff_date}
        })
        
        if result.deleted_count > 0:
            logger.info(f"üóëÔ∏è Cleanup: Deleted {result.deleted_count} bills older than 6 months (before {cutoff_date.date()})")
        
        return result.deleted_count
    
    except Exception as e:
        logger.error(f"Error during cleanup: {str(e)}")
        return 0

def check_and_cleanup():
    """Check if we're in a new month and cleanup old data"""
    try:
        # Get the latest bill to check if we need cleanup
        latest_bill = bills_col.find_one(
            {},
            sort=[("createdAt", -1)]
        )
        
        if latest_bill and "createdAt" in latest_bill:
            oldest_bill = bills_col.find_one(
                {},
                sort=[("createdAt", 1)]
            )
            
            if oldest_bill and "createdAt" in oldest_bill:
                months_diff = (latest_bill["createdAt"] - oldest_bill["createdAt"]).days / 30
                
                # If we have 7+ months of data, cleanup the oldest month
                if months_diff >= 7:
                    cleanup_old_bills()
    
    except Exception as e:
        logger.warning(f"Could not perform automatic cleanup check: {str(e)}")

# App setup
app = Flask(__name__, static_folder=".", static_url_path="")
app.config['JWT_SECRET_KEY'] = os.getenv("JWT_SECRET_KEY", "your-secret-key-change-in-production")
app.config['JWT_ACCESS_TOKEN_EXPIRES'] = timedelta(days=30)
jwt = JWTManager(app)
CORS(app, resources={r"/api/*": {"origins": "*", "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS"]}})

@app.errorhandler(404)
def not_found(error):
    # Only return JSON for API routes
    if request.path.startswith('/api/'):
        return jsonify({"success": False, "error": "Not Found"}), 404
    # For HTML files, return a simple HTML error page
    return "<h1>404 - Page Not Found</h1><p>The page you are looking for does not exist.</p>", 404

@app.errorhandler(500)
def internal_error(error):
    logger.error(f"Internal error: {str(error)}")
    return jsonify({"success": False, "error": "Internal Server Error"}), 500

def validate_bill_data(data):
    """Validate bill data before saving to database"""
    if not isinstance(data, dict):
        return False, "Invalid request format"
    
    if not isinstance(data.get("items"), list):
        return False, "Items must be an array"
    
    total = data.get("total", 0)
    if not isinstance(total, (int, float)) or total < 0:
        return False, "Invalid total amount"
    
    payment = data.get("payment", "").strip()
    # Accept both individual and combined payment methods (updated to match frontend)
    valid_payments = ["Cash", "Card", "UPI", "Cash / UPI", "Cash/UPI"]
    if payment and payment not in valid_payments:
        return False, f"Invalid payment method: {payment}"
    
    order_type = data.get("orderType", "").strip()
    # Accept both individual and combined order types (updated to match frontend)
    valid_order_types = ["Dine-in", "Take Out", "Dine-in / Take Out", "Zomato", "Swiggy", "Swiggy / Zomato"]
    if order_type and order_type not in valid_order_types:
        return False, f"Invalid order type: {order_type}"
    
    return True, ""

# ============ FRONTEND ROUTES ============

@app.route("/")
def home():
    """Serve main POS system"""
    try:
        import os
        base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        frontend_path = os.path.join(base_dir, "frontend")
        return send_from_directory(frontend_path, "index.html")
    except Exception as e:
        logger.error(f"Error serving index.html: {str(e)}")
        return jsonify({"error": "Could not load POS system"}), 500

@app.route("/index.html")
def index_html():
    """Serve main POS system (alternative route)"""
    return home()

@app.route("/analytics.html")
def analytics():
    """Serve analytics dashboard"""
    try:
        import os
        base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        frontend_path = os.path.join(base_dir, "frontend")
        return send_from_directory(frontend_path, "analytics.html")
    except Exception as e:
        logger.error(f"Error serving analytics.html: {str(e)}")
        return jsonify({"error": "Could not load analytics"}), 500

@app.route("/analytics")
def analytics_route():
    """Serve analytics dashboard (alternative route)"""
    return analytics()

@app.route("/index")
def index_route():
    """Serve main POS system (alternative route without .html)"""
    return home()

@app.route("/login.html")
def serve_login():
    """Serve login page"""
    try:
        import os
        base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        frontend_path = os.path.join(base_dir, "frontend")
        file_path = os.path.join(frontend_path, "login.html")
        logger.info(f"Attempting to serve login.html from: {file_path}")
        logger.info(f"File exists: {os.path.exists(file_path)}")
        return send_from_directory(frontend_path, "login.html")
    except Exception as e:
        logger.error(f"Error serving login.html: {str(e)}")
        import traceback
        logger.error(traceback.format_exc())
        return jsonify({"error": "Could not load login page", "detail": str(e)}), 500

@app.route("/login")
def login():
    """Serve login page (alternative route)"""
    return serve_login()

# ============ AUTHENTICATION ============

def validate_email(email):
    """Validate email format"""
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return re.match(pattern, email) is not None

@app.route("/api/auth/login", methods=["POST"])
def api_login():
    """User login endpoint"""
    try:
        data = request.get_json()
        
        if not data.get('email') or not data.get('password'):
            return jsonify({"success": False, "error": "Email and password required"}), 400
        
        # Find user by email
        user = users_col.find_one({"email": data['email'].lower()})
        
        if not user:
            return jsonify({"success": False, "error": "Invalid credentials"}), 401
        
        # Verify password
        if not verify_password(data['password'], user['password']):
            return jsonify({"success": False, "error": "Invalid credentials"}), 401
        
        # Create access token
        access_token = create_access_token(identity=str(user['_id']))
        
        logger.info(f"‚úÖ User logged in: {user['username']}")
        return jsonify({
            "success": True,
            "message": "Login successful",
            "token": access_token,
            "user": {
                "id": str(user['_id']),
                "username": user['username'],
                "email": user['email'],
                "role": user.get('role', 'staff')
            }
        }), 200
        
    except Exception as e:
        logger.error(f"Login error: {str(e)}")
        return jsonify({"success": False, "error": "Login failed"}), 500

@app.route("/api/auth/verify", methods=["GET"])
@jwt_required()
def verify_token():
    """Verify if token is valid"""
    try:
        user_id = get_jwt_identity()
        user = users_col.find_one({"_id": ObjectId(user_id)})
        
        if not user:
            return jsonify({"success": False, "error": "User not found"}), 404
        
        return jsonify({
            "success": True,
            "user": {
                "id": str(user['_id']),
                "username": user['username'],
                "email": user['email'],
                "role": user.get('role', 'staff')
            }
        }), 200
        
    except Exception as e:
        logger.error(f"Token verification error: {str(e)}")
        return jsonify({"success": False, "error": "Invalid token"}), 401

def check_and_reset_daily_counter():
    """Check if 24 hours have passed and reset counter if needed"""
    try:
        # Get or initialize counter from database
        counter = counter_col.find_one({"_id": "token"})
        
        if not counter:
            # Initialize new counter
            counter_col.insert_one({
                "_id": "token",
                "value": 0,
                "lastReset": datetime.now()
            })
            return 0, False
        
        # Check if 24 hours have passed since last reset
        last_reset = counter.get("lastReset", datetime.now())
        hours_passed = (datetime.now() - last_reset).total_seconds() / 3600
        
        # Reset counter to 1 if 24 hours have passed
        if hours_passed >= 24:
            counter_col.update_one(
                {"_id": "token"},
                {"$set": {"value": 1, "lastReset": datetime.now()}}
            )
            logger.info(f"‚ôªÔ∏è Daily Bill Counter Reset - Bill #1 {hours_passed:.1f} hours elapsed since last reset")
            return 1, True
        
        # Return current value and reset status
        return counter.get("value", 0), False
        
    except Exception as e:
        logger.error(f"Error in counter reset check: {str(e)}")
        return 0, False

@app.route("/api/token", methods=["GET"])
def get_token():
    """Fetch and increment bill token from database"""
    try:
        # Check and reset if 24 hours have passed
        current_value, was_reset = check_and_reset_daily_counter()
        
        # If just reset, return 1 without incrementing
        if was_reset:
            logger.info(f"Bill counter reset detected - Returning Bill #1")
            return jsonify({
                "success": True,
                "token": 1
            }), 200
        
        # Increment counter and get new value from database
        token_doc = counter_col.find_one_and_update(
            {"_id": "token"},
            {"$inc": {"value": 1}},
            return_document=True
        )
        
        if not token_doc or "value" not in token_doc:
            raise ValueError("Failed to fetch token from database")
        
        bill_number = token_doc["value"]
        logger.debug(f"Bill #{bill_number} generated from database counter")
        
        return jsonify({
            "success": True,
            "token": bill_number
        }), 200
    
    except Exception as e:
        logger.error(f"Error generating token: {str(e)}")
        return jsonify({
            "success": False,
            "error": "Failed to generate token"
        }), 500

@app.route("/api/token/current", methods=["GET"])
def get_current_token():
    """Fetch current bill token from database without incrementing"""
    try:
        # Check and reset if 24 hours have passed
        current_value, was_reset = check_and_reset_daily_counter()
        
        # If just reset, return 1
        if was_reset:
            return jsonify({
                "success": True,
                "token": 1
            }), 200
        
        # Fetch current value from database
        token_doc = counter_col.find_one({"_id": "token"})
        
        if not token_doc:
            token_doc = {"value": 0}
        
        current_bill_number = token_doc.get("value", 0)
        next_bill_number = current_bill_number + 1
        
        logger.debug(f"Current Bill: #{current_bill_number}, Next Bill will be: #{next_bill_number}")
        
        return jsonify({
            "success": True,
            "token": current_bill_number
        }), 200
    
    except Exception as e:
        logger.error(f"Error fetching current token: {str(e)}")
        return jsonify({
            "success": False,
            "error": "Failed to fetch current token"
        }), 500

# ============ BILL MANAGEMENT ============

@app.route("/api/bill", methods=["POST"])
def save_bill():
    """Save a new bill to the database"""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({
                "success": False,
                "error": "No data provided"
            }), 400
        
        # Validate bill data
        is_valid, error_msg = validate_bill_data(data)
        if not is_valid:
            return jsonify({
                "success": False,
                "error": error_msg
            }), 400
        
        # Prepare bill document
        bill = {
            "items": data.get("items", []),
            "total": float(data.get("total", 0)),
            "payment": data.get("payment", "Unknown").strip(),
            "orderType": data.get("orderType", "Unknown").strip(),
            "token": int(data.get("token", 0)),
            "createdAt": datetime.now(),
            "createdAtISO": datetime.now().isoformat()
        }
        
        # Save to database
        result = bills_col.insert_one(bill)
        
        logger.info(f"‚úÖ Bill saved - Token: {bill['token']}, Total: ‚Çπ{bill['total']}, Items: {len(bill['items'])}")
        
        return jsonify({
            "success": True,
            "message": "Bill saved successfully",
            "billId": str(result.inserted_id),
            "token": bill["token"]
        }), 201
    
    except Exception as e:
        logger.error(f"Error saving bill: {str(e)}")
        return jsonify({
            "success": False,
            "error": "Failed to save bill"
        }), 500

@app.route("/api/bills", methods=["GET"])
def get_bills():
    """Retrieve all bills with optional filters"""
    try:
        # Check and cleanup old bills on each analytics page load
        check_and_cleanup()
        
        # Optional query parameters
        days = request.args.get("days", type=int, default=None)
        payment = request.args.get("payment", default=None)
        order_type = request.args.get("orderType", default=None)
        limit = request.args.get("limit", type=int, default=1000)
        include_deleted = request.args.get("includeDeleted", default="false").lower() == "true"
        
        # Build filter
        filter_query = {}
        
        if days:
            cutoff_date = datetime.now() - timedelta(days=days)
            filter_query["createdAt"] = {"$gte": cutoff_date}
        
        if payment:
            filter_query["payment"] = payment
        
        if order_type:
            filter_query["orderType"] = order_type
        
        # Exclude soft-deleted bills unless specifically requested
        if not include_deleted:
            filter_query["deleted"] = {"$ne": True}
        
        # Fetch and return bills (sort by token number descending to show latest bills first)
        bills = list(
            bills_col.find(filter_query, {"_id": 0})
            .sort("token", -1)
            .limit(limit)
        )
        
        # Convert datetime objects to ISO format strings for JSON serialization
        for bill in bills:
            if isinstance(bill.get('createdAt'), datetime):
                bill['createdAt'] = bill['createdAt'].isoformat()
            if isinstance(bill.get('createdAtISO'), str):
                # Already a string, keep it
                pass
        
        logger.debug(f"Fetching bills: Found {len(bills)} bills")
        return jsonify(bills), 200
    
    except Exception as e:
        logger.error(f"Error fetching bills: {str(e)}")
        # Return empty array on database error instead of error response
        return jsonify([]), 200

@app.route("/api/bill/<token>", methods=["GET"])
def get_bill(token):
    """Get a specific bill by token number"""
    try:
        bill = bills_col.find_one(
            {"token": int(token)},
            {"_id": 0}
        )
        
        if not bill:
            return jsonify({
                "success": False,
                "error": "Bill not found"
            }), 404
        
        return jsonify({
            "success": True,
            "bill": bill
        }), 200
    
    except ValueError:
        return jsonify({
            "success": False,
            "error": "Invalid token"
        }), 400
    
    except Exception as e:
        logger.error(f"Error fetching bill: {str(e)}")
        return jsonify({
            "success": False,
            "error": "Failed to fetch bill"
        }), 500

@app.route("/api/bill/<token>/delete", methods=["PUT"])
@jwt_required()
def delete_bill(token):
    """Soft-delete a bill (mark as deleted instead of permanent removal)"""
    try:
        # Get current user
        current_user_id = get_jwt_identity()
        user = users_col.find_one({"_id": ObjectId(current_user_id)})
        
        # Check if user is admin
        if not user or user.get('role') != 'admin':
            return jsonify({"success": False, "error": "Admin access required"}), 403
        
        token_int = int(token)
        result = bills_col.update_one(
            {"token": token_int},
            {"$set": {"deleted": True}}
        )
        
        if result.matched_count == 0:
            return jsonify({
                "success": False,
                "error": "Bill not found"
            }), 404
        
        logger.info(f"‚úÖ Bill marked as deleted - Token: {token_int}")
        
        return jsonify({
            "success": True,
            "message": "Bill marked as deleted"
        }), 200
    
    except ValueError:
        return jsonify({
            "success": False,
            "error": "Invalid token"
        }), 400
    
    except Exception as e:
        logger.error(f"Error deleting bill: {str(e)}")
        return jsonify({
            "success": False,
            "error": "Failed to delete bill"
        }), 500

@app.route("/api/bill/<token>/restore", methods=["PUT"])
@jwt_required()
def restore_bill(token):
    """Restore a soft-deleted bill (unhide)"""
    try:
        # Get current user
        current_user_id = get_jwt_identity()
        user = users_col.find_one({"_id": ObjectId(current_user_id)})
        
        # Check if user is admin
        if not user or user.get('role') != 'admin':
            return jsonify({"success": False, "error": "Admin access required"}), 403
        
        token_int = int(token)
        result = bills_col.update_one(
            {"token": token_int},
            {"$set": {"deleted": False}}
        )
        
        if result.matched_count == 0:
            return jsonify({
                "success": False,
                "error": "Bill not found"
            }), 404
        
        logger.info(f"‚úÖ Bill restored - Token: {token_int}")
        
        return jsonify({
            "success": True,
            "message": "Bill restored successfully"
        }), 200
    
    except ValueError:
        return jsonify({
            "success": False,
            "error": "Invalid token"
        }), 400
    
    except Exception as e:
        logger.error(f"Error restoring bill: {str(e)}")
        return jsonify({
            "success": False,
            "error": "Failed to restore bill"
        }), 500

@app.route("/api/bill/<token>/permanent-delete", methods=["DELETE"])
@jwt_required()
def permanent_delete_bill(token):
    """Permanently delete a bill from database (admin only)"""
    try:
        # Get current user
        current_user_id = get_jwt_identity()
        user = users_col.find_one({"_id": ObjectId(current_user_id)})
        
        # Check if user is admin
        if not user or user.get('role') != 'admin':
            return jsonify({"success": False, "error": "Admin access required"}), 403
        token_int = int(token)
        result = bills_col.delete_one({"token": token_int})
        
        if result.deleted_count == 0:
            return jsonify({
                "success": False,
                "error": "Bill not found"
            }), 404
        
        logger.warning(f"‚ö†Ô∏è Bill permanently deleted - Token: {token_int}")
        
        return jsonify({
            "success": True,
            "message": "Bill permanently deleted"
        }), 200
    
    except ValueError:
        return jsonify({
            "success": False,
            "error": "Invalid token"
        }), 400
    
    except Exception as e:
        logger.error(f"Error permanently deleting bill: {str(e)}")
        return jsonify({
            "success": False,
            "error": "Failed to permanently delete bill"
        }), 500

# ============ ANALYTICS ENDPOINTS ============

@app.route("/api/sales", methods=["GET"])
def daily_sales():
    """Get sales summary for today"""
    try:
        today = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        
        bills = list(bills_col.find(
            {"createdAt": {"$gte": today}, "deleted": {"$ne": True}},
            {"_id": 0}
        ))
        
        total_sales = sum(b.get("total", 0) for b in bills)
        
        # Sales by payment method
        payment_breakdown = {}
        for bill in bills:
            payment = bill.get("payment", "Unknown")
            payment_breakdown[payment] = payment_breakdown.get(payment, 0) + bill.get("total", 0)
        
        # Sales by order type
        order_type_breakdown = {}
        for bill in bills:
            order_type = bill.get("orderType", "Unknown")
            order_type_breakdown[order_type] = order_type_breakdown.get(order_type, 0) + bill.get("total", 0)
        
        return jsonify({
            "success": True,
            "date": today.isoformat(),
            "billCount": len(bills),
            "totalSales": total_sales,
            "averageBill": round(total_sales / len(bills), 2) if bills else 0,
            "paymentBreakdown": payment_breakdown,
            "orderTypeBreakdown": order_type_breakdown
        }), 200
    
    except Exception as e:
        logger.error(f"Error calculating sales: {str(e)}")
        return jsonify({
            "success": False,
            "error": "Failed to calculate sales"
        }), 500

@app.route("/api/analytics/summary", methods=["GET"])
def analytics_summary():
    """Get comprehensive analytics summary"""
    try:
        # Today's date range
        today = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        
        # Fetch all bills (excluding soft-deleted)
        all_bills = list(bills_col.find({"deleted": {"$ne": True}}, {"_id": 0}).sort("createdAt", -1))
        
        # Today's bills
        today_bills = [b for b in all_bills if b.get("createdAt", datetime.now()).replace(hour=0, minute=0, second=0, microsecond=0) == today]
        
        # Last 7 days bills
        seven_days_ago = today - timedelta(days=7)
        week_bills = [b for b in all_bills if b.get("createdAt", datetime.now()) >= seven_days_ago]
        
        # Calculate totals
        today_total = sum(b.get("total", 0) for b in today_bills)
        week_total = sum(b.get("total", 0) for b in week_bills)
        total_all_time = sum(b.get("total", 0) for b in all_bills)
        
        return jsonify({
            "success": True,
            "today": {
                "billCount": len(today_bills),
                "totalSales": today_total,
                "averageBill": round(today_total / len(today_bills), 2) if today_bills else 0
            },
            "week": {
                "billCount": len(week_bills),
                "totalSales": week_total,
                "averageBill": round(week_total / len(week_bills), 2) if week_bills else 0
            },
            "allTime": {
                "billCount": len(all_bills),
                "totalSales": total_all_time,
                "averageBill": round(total_all_time / len(all_bills), 2) if all_bills else 0
            }
        }), 200
    
    except Exception as e:
        logger.error(f"Error generating analytics summary: {str(e)}")
        return jsonify({
            "success": False,
            "error": "Failed to generate analytics"
        }), 500

@app.route("/api/health", methods=["GET"])
def health_check():
    """Health check endpoint"""
    try:
        client.admin.command('ping')
        return jsonify({
            "success": True,
            "status": "healthy",
            "database": "connected"
        }), 200
    except Exception as e:
        logger.error(f"Health check failed: {str(e)}")
        return jsonify({
            "success": False,
            "status": "unhealthy",
            "database": "disconnected"
        }), 500

# ============ CUSTOM MENU ITEMS ============

@app.route("/api/custom-items", methods=["GET"])
@jwt_required()
def get_custom_items():
    """Get all custom menu items"""
    try:
        items = list(custom_items_col.find({}, {"_id": 0}))
        return jsonify({
            "success": True,
            "items": items
        }), 200
    except Exception as e:
        logger.error(f"Error fetching custom items: {str(e)}")
        return jsonify({
            "success": False,
            "error": "Failed to fetch custom items"
        }), 500

@app.route("/api/custom-items", methods=["POST"])
@jwt_required()
def add_custom_item():
    """Add a new custom menu item"""
    try:
        data = request.get_json()
        
        if not data or not data.get("name") or not data.get("price"):
            return jsonify({
                "success": False,
                "error": "Name and price are required"
            }), 400
        
        item = {
            "name": data["name"].strip(),
            "price": float(data["price"]),
            "category": data.get("category", "Custom").strip(),
            "createdAt": datetime.now(),
            "createdBy": get_jwt_identity()
        }
        
        # Check if item already exists
        existing = custom_items_col.find_one({"name": item["name"]})
        if existing:
            return jsonify({
                "success": False,
                "error": "Item with this name already exists"
            }), 400
        
        custom_items_col.insert_one(item)
        
        logger.info(f"‚úÖ Custom item added: {item['name']} - ‚Çπ{item['price']}")
        
        return jsonify({
            "success": True,
            "message": "Custom item added successfully",
            "item": {
                "name": item["name"],
                "price": item["price"],
                "category": item["category"]
            }
        }), 201
    except Exception as e:
        logger.error(f"Error adding custom item: {str(e)}")
        return jsonify({
            "success": False,
            "error": "Failed to add custom item"
        }), 500

@app.route("/api/custom-items/<name>", methods=["DELETE"])
@jwt_required()
def delete_custom_item(name):
    """Delete a custom menu item (Admin only)"""
    try:
        # Get current user from JWT
        current_user_email = get_jwt_identity()
        user = users_col.find_one({"email": current_user_email})
        
        # Check if user is admin
        if not user or user.get('role') != 'admin':
            return jsonify({"success": False, "error": "Admin access required"}), 403
        
        result = custom_items_col.delete_one({"name": name})
        
        if result.deleted_count == 0:
            return jsonify({
                "success": False,
                "error": "Item not found"
            }), 404
        
        logger.info(f"‚úÖ Custom item deleted: {name}")
        
        return jsonify({
            "success": True,
            "message": "Custom item deleted successfully"
        }), 200
    except Exception as e:
        logger.error(f"Error deleting custom item: {str(e)}")
        return jsonify({
            "success": False,
            "error": "Failed to delete custom item"
        }), 500

# ============ ERROR HANDLING ============

@app.before_request
def log_request():
    """Log incoming requests"""
    logger.debug(f"{request.method} {request.path}")

@app.after_request
def log_response(response):
    """Log outgoing responses"""
    logger.debug(f"Response status: {response.status_code}")
    return response

# ============ SERVER START ============

if __name__ == "__main__":
    port = int(os.getenv("PORT", 5000))
    debug_mode = os.getenv("DEBUG", "True").lower() == "true"
    
    logger.info(f"üöÄ Starting Flask server on port {port} (Debug: {debug_mode})")
    logger.info("üìä Analytics available at http://localhost:{}/analytics.html".format(port))
    logger.info("üí≥ POS System available at http://localhost:{}/".format(port))
    
    # Check and cleanup old bills on startup
    check_and_cleanup()
    
    app.run(
        debug=debug_mode,
        port=port,
        host="0.0.0.0",
        use_reloader=False
    )

